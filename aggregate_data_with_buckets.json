[
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Bucket",
        "metadata": {
            "name": "cranky-aggtopic-458001"
        },
        "spec": {
            "name": "default_agg_topic"
        }
    },
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Bucket",
        "metadata": {
            "name": "cranky-aggtopic2-458001"
        },
        "spec": {
            "name": "default_agg_topic_2"
        }
    },
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Bucket",
        "metadata": {
            "name": "cranky-aggstats-458001"
        },
        "spec": {
            "name": "default_agg_stats"
        }
    },
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Bucket",
        "metadata": {
            "name": "cranky-aggkpi-458001"
        },
        "spec": {
            "name": "default_agg_kpi"
        }
    },
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Bucket",
        "metadata": {
            "name": "cranky-aggchatid-458001"
        },
        "spec": {
            "name": "default_agg_chatid"
        }
    },
    {
        "apiVersion": "influxdata.com/v2alpha1",
        "kind": "Task",
        "metadata": {
            "name": "lucid-carver-379001"
        },
        "spec": {
            "cron": "0 */6 * * *",
            "name": "aggregate_data",
            "offset": "2m0s",
            "query": "\nimport \"experimental\"\nimport \"influxdata/influxdb/schema\"\nimport \"influxdata/influxdb/secrets\"\n// Define the task with a cron schedule (runs every 6 hours), with an offset of 2 minutes and retry up to 3 times\n// Define the Organization name\n\noption org = secrets.get(key: \"org\")\n// Define the bucket from which data is read\noption fromBucket = secrets.get(key: \"bucket\")\n// Get the current time\n\nnow_time = now()\n\n// Define the start time for the data aggregation (6 hours before the current time)\n\nstart_time = experimental.addDuration(d: -6h, to: now_time)\n\n// Define the stop time for the data aggregation (current time)\n\nstop_time = experimental.addDuration(d: -1s, to: now_time)\n\n// Define the buckets where the aggregated data will be stored\n\ntoBucket_agg = \"default_agg_topic\"\n\ntoBucket_agg_2 = \"default_agg_topic_2\"\n\n// Bucket for aggregated topic data\n\ntoBucket_stats = \"default_agg_stats\"\n\n// Bucket for aggregated kpi data\n\ntoBucket_kpi = \"default_agg_kpi\"\n\ntoBucket_chatid = \"default_agg_chatid\"\n\n// Bucket for aggregated stats data\n// Query the data from the default bucket within the specified time range\ndata =\n    from(bucket: \"default\")\n        |> range(start: start_time, stop: stop_time)\n        |> filter(fn: (r) => r._measurement == \"analytics\")\n        //|> pivot(rowKey: [\"_time\"], columnKey: [\"_field\"], valueColumn: \"_value\")\n        |> schema.fieldsAsCols()\n        |> group()\n\n// Pivot data into columns by field names\n// Aggregating prompt_tokens and storing the results\ndata\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    |> sum(column: \"prompt_tokens\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"prompt_tokens\",\n                _value: int(v: r.prompt_tokens),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n// Aggregating completion_tokens and storing the results\ndata\n    // Group by _measurement, title, topic, and use the start of the range as the key for _time\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    |> sum(column: \"completion_tokens\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"completion_tokens\",\n                _value: int(v: r.completion_tokens),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n// Aggregating price and storing the results\ndata\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    |> sum(column: \"price\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"price\",\n                _value: float(v: r.price),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n// Aggregating number_request_messages and storing the results\ndata\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    // Sum number_request_messages\n    |> sum(column: \"number_request_messages\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"number_request_messages\",\n                _value: int(v: r.number_request_messages),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\ndata\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    // Sum number_request_messages\n    |> sum(column: \"deployment_price\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"deployment_price\",\n                _value: int(v: r.deployment_price),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n//Aggregating data on the min time over the groupby columns in order to keep all unique user_hash-es\ndata\n    // Floor the _time column to 6-hour intervals before aggregation\n    |> map(\n        fn: (r) =>\n            ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000)}),\n    )\n    // Group the data by the desired columns (_floored_time, _measurement, and other dimensions)\n    |> group(\n        columns: [\n            \"_floored_time\",\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n            \"user_hash\",\n        ],\n    )\n    |> min(column: \"_time\")\n    // Find the minimum time for each group\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"user_hash\",\n                _value: string(v: r.user_hash),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n// Counting the number of requests (user_hash) for the group\ndata\n    |> group(\n        columns: [\n            \"_measurement\",\n            \"deployment\",\n            \"model\",\n            \"project_id\",\n            \"parent_deployment\",\n            \"language\",\n        ],\n    )\n    |> count(column: \"user_hash\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                deployment: r.deployment,\n                model: r.model,\n                project_id: r.project_id,\n                parent_deployment: r.parent_deployment,\n                language: r.language,\n                _field: \"request_count\",\n                _value: int(v: r.user_hash),\n            }),\n    )\n    |> to(bucket: toBucket_stats, org: org)\n\n// Counting the topic using user_hash\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    // Sum number_request_messages directly\n    |> count(column: \"user_hash\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"topic_count\",\n                _value: int(v: r.user_hash),\n            }),\n    )\n    |> to(bucket: toBucket_agg_2, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    |> sum(column: \"number_request_messages\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"number_request_messages\",\n                _value: int(v: r.number_request_messages),\n            }),\n    )\n    |> to(bucket: toBucket_agg_2, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    // Sum number_request_messages directly\n    |> count(column: \"user_hash\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"topic_count\",\n                _value: int(v: r.user_hash),\n            }),\n    )\n    |> to(bucket: toBucket_agg, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    |> sum(column: \"number_request_messages\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"number_request_messages\",\n                _value: int(v: r.number_request_messages),\n            }),\n    )\n    |> to(bucket: toBucket_agg, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    |> sum(column: \"price\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"price\",\n                _value: float(v: r.price),\n            }),\n    )\n    |> to(bucket: toBucket_agg_2, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    |> sum(column: \"prompt_tokens\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"prompt_tokens\",\n                _value: int(v: r.prompt_tokens),\n            }),\n    )\n    |> to(bucket: toBucket_agg_2, org: org)\n\ndata\n    |> group(columns: [\"_measurement\", \"title\", \"topic\", \"model\"])\n    |> sum(column: \"completion_tokens\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                title: r.title,\n                topic: r.topic,\n                model: r.model,\n                _field: \"completion_tokens\",\n                _value: int(v: r.completion_tokens),\n            }),\n    )\n    |> to(bucket: toBucket_agg_2, org: org)\n\n//classification of prompt tokens\ndata\n    |> map(\n        fn: (r) => ({r with user_type: if r.user_hash == \"undefined\" then \"project\" else \"user\"}),\n    )\n    |> group(columns: [\"_measurement\", \"user_type\"])\n    |> map(\n        fn: (r) =>\n            ({\n                _measurement: r._measurement,\n                user_type: r.user_type,\n                prompt_tokens: r.prompt_tokens,\n                prompt_token_class:\n                    if r.prompt_tokens >= 50000 then\n                        \"class_1\"\n                    else if r.prompt_tokens > 10000 then\n                        \"class_2\"\n                    else if r.prompt_tokens > 5000 then\n                        \"class_3\"\n                    else if r.prompt_tokens > 1000 then\n                        \"class_4\"\n                    else if r.prompt_tokens > 100 then\n                        \"class_5\"\n                    else\n                        \"class_6\",\n            }),\n    )\n    |> group(columns: [\"_measurement\", \"user_type\", \"prompt_token_class\"])\n    |> count(column: \"prompt_tokens\")\n    |> map(\n        fn: (r) =>\n            ({\n                _time: start_time,\n                _measurement: r._measurement,\n                user_type: r.user_type,\n                _field: r.prompt_token_class,\n                _value: int(v: r.prompt_tokens),\n            }),\n    )\n    |> to(bucket: toBucket_agg, org: org)\n\n// processing data for kpi bucket\ngetOrDefault = (f, d) => if exists f then f else d\n\nkpi_data =\n    data\n        |> map(fn: (r) => ({r with request_count: 1}))\n        |> map(\n            fn: (r) =>\n                ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000),\n                }),\n        )\n        |> group(\n            columns: [\n                \"_floored_time\",\n                \"user_hash\",\n                \"project_id\",\n                \"title\",\n                // \"chat_id\",\n                \"parent_deployment\",\n            ],\n        )\n        |> reduce(\n            fn: (r, accumulator) =>\n                ({\n                    request_count:\n                        getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,\n                    completion_tokens:\n                        getOrDefault(f: r.completion_tokens, d: 0) + accumulator.completion_tokens,\n                    prompt_tokens:\n                        getOrDefault(f: r.prompt_tokens, d: 0) + accumulator.prompt_tokens,\n                    price: getOrDefault(f: r.price, d: 0.0) + accumulator.price,\n                }),\n            identity: {request_count: 0, price: 0.0, completion_tokens: 0, prompt_tokens: 0},\n        )\n\nkpi_data\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._floored_time,\n                _measurement: \"analytics\",\n                user_hash: r.user_hash,\n                project_id: r.project_id,\n                // chat_id: r.chat_id,\n                parent_deployment: r.parent_deployment,\n                title: r.title,\n                _field: \"cost\",\n                _value: r.price,\n            }),\n    )\n    |> to(bucket: toBucket_kpi, org: org)\n\nkpi_data\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._floored_time,\n                _measurement: \"analytics\",\n                user_hash: r.user_hash,\n                project_id: r.project_id,\n                // chat_id: r.chat_id,\n                parent_deployment: r.parent_deployment,\n                title: r.title,\n                _field: \"request_count\",\n                _value: r.request_count,\n            }),\n    )\n    |> to(bucket: toBucket_kpi, org: org)\nkpi_data\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._floored_time,\n                _measurement: \"analytics\",\n                user_hash: r.user_hash,\n                project_id: r.project_id,\n                //  chat_id: r.chat_id,\n                parent_deployment: r.parent_deployment,\n                title: r.title,\n                _field: \"completion_tokens\",\n                _value: r.completion_tokens,\n            }),\n    )\n    |> to(bucket: toBucket_kpi, org: org)\nkpi_data\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._floored_time,\n                _measurement: \"analytics\",\n                user_hash: r.user_hash,\n                project_id: r.project_id,\n                // chat_id: r.chat_id,\n                parent_deployment: r.parent_deployment,\n                title: r.title,\n                _field: \"prompt_tokens\",\n                _value: r.prompt_tokens,\n            }),\n    )\n    |> to(bucket: toBucket_kpi, org: org)\n\nchat_id_data =\n    data\n        |> map(fn: (r) => ({r with request_count: 1}))\n        |> map(\n            fn: (r) =>\n                ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000),\n                }),\n        )\n        |> group(columns: [\"_floored_time\", \"chat_id\"])\n        |> reduce(\n            fn: (r, accumulator) =>\n                ({\n                    request_count:\n                        getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,\n                }),\n            identity: {request_count: 0},\n        )\n\nchat_id_data\n    |> map(\n        fn: (r) =>\n            ({\n                _time: r._floored_time,\n                _measurement: \"analytics\",\n                chat_id: r.chat_id,\n                _field: \"request_count\",\n                _value: r.request_count,\n            }),\n    )\n    |> to(bucket: toBucket_chatid, org: org)"
        }
    }
]
