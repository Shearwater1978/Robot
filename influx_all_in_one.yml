apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: annoying-shannon-dd800b
spec:
    name: default_agg_topic
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: brave-gould-dd8007
spec:
    name: default_agg_month
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: busy-gagarin-dd8005
spec:
    name: default_agg_kpi
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: busy-swanson-dd800d
spec:
    name: default_agg_topic_2
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: nice-edison-dd8001
spec:
    name: default
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: priceless-gagarin-dd8003
spec:
    name: default_agg_chatid
---
apiVersion: influxdata.com/v2alpha1
kind: Bucket
metadata:
    name: sleepy-knuth-dd8009
spec:
    name: default_agg_stats
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: quirky-blackwell-1d8003
spec:
    cron: 0 */6 * * *
    name: aggregate_data
    offset: 2m0s
    query: |-
        import "experimental"
        import "influxdata/influxdb/schema"
        import "influxdata/influxdb/secrets"



        // Define the task with a cron schedule (runs every 6 hours), with an offset of 2 minutes and retry up to 3 times
        // Define the Organization name

        option org = secrets.get(key: "org")
        // Define the bucket from which data is read
        option fromBucket = secrets.get(key: "bucket")
        // Get the current time

        now_time = now()

        // Define the start time for the data aggregation (6 hours before the current time)

        start_time = experimental.addDuration(d: -6h, to: now_time)

        // Define the stop time for the data aggregation (current time)

        stop_time = experimental.addDuration(d: -1s, to: now_time)

        // Define the buckets where the aggregated data will be stored

        toBucket_agg = "default_agg_topic"

        toBucket_agg_2 = "default_agg_topic_2"

        // Bucket for aggregated topic data

        toBucket_stats = "default_agg_stats"

        // Bucket for aggregated kpi data

        toBucket_kpi = "default_agg_kpi"

        toBucket_chatid = "default_agg_chatid"

        // Bucket for aggregated stats data
        // Query the data from the default bucket within the specified time range
        data =
            from(bucket: "default")
                |> range(start: start_time, stop: stop_time)
                |> filter(fn: (r) => r._measurement == "analytics")
                //|> pivot(rowKey: ["_time"], columnKey: ["_field"], valueColumn: "_value")
                |> schema.fieldsAsCols()
                |> group()

        // Pivot data into columns by field names
        // Aggregating prompt_tokens and storing the results
        data
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            |> sum(column: "prompt_tokens")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "prompt_tokens",
                        _value: int(v: r.prompt_tokens),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        // Aggregating completion_tokens and storing the results
        data
            // Group by _measurement, title, topic, and use the start of the range as the key for _time
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            |> sum(column: "completion_tokens")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "completion_tokens",
                        _value: int(v: r.completion_tokens),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        // Aggregating price and storing the results
        data
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            |> sum(column: "price")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "price",
                        _value: float(v: r.price),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        // Aggregating number_request_messages and storing the results
        data
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            // Sum number_request_messages
            |> sum(column: "number_request_messages")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "number_request_messages",
                        _value: int(v: r.number_request_messages),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        data
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            // Sum number_request_messages
            |> sum(column: "deployment_price")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "deployment_price",
                        _value: int(v: r.deployment_price),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        //Aggregating data on the min time over the groupby columns in order to keep all unique user_hash-es
        data
            // Floor the _time column to 6-hour intervals before aggregation
            |> map(
                fn: (r) =>
                    ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000)}),
            )
            // Group the data by the desired columns (_floored_time, _measurement, and other dimensions)
            |> group(
                columns: [
                    "_floored_time",
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                    "user_hash",
                ],
            )
            |> min(column: "_time")
            // Find the minimum time for each group
            |> map(
                fn: (r) =>
                    ({
                        _time: r._time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "user_hash",
                        _value: string(v: r.user_hash),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        // Counting the number of requests (user_hash) for the group
        data
            |> group(
                columns: [
                    "_measurement",
                    "deployment",
                    "model",
                    "project_id",
                    "parent_deployment",
                    "language",
                ],
            )
            |> count(column: "user_hash")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        deployment: r.deployment,
                        model: r.model,
                        project_id: r.project_id,
                        parent_deployment: r.parent_deployment,
                        language: r.language,
                        _field: "request_count",
                        _value: int(v: r.user_hash),
                    }),
            )
            |> to(bucket: toBucket_stats, org: org)

        // Counting the topic using user_hash
        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            // Sum number_request_messages directly
            |> count(column: "user_hash")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "topic_count",
                        _value: int(v: r.user_hash),
                    }),
            )
            |> to(bucket: toBucket_agg_2, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            |> sum(column: "number_request_messages")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "number_request_messages",
                        _value: int(v: r.number_request_messages),
                    }),
            )
            |> to(bucket: toBucket_agg_2, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            // Sum number_request_messages directly
            |> count(column: "user_hash")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "topic_count",
                        _value: int(v: r.user_hash),
                    }),
            )
            |> to(bucket: toBucket_agg, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            |> sum(column: "number_request_messages")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "number_request_messages",
                        _value: int(v: r.number_request_messages),
                    }),
            )
            |> to(bucket: toBucket_agg, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            |> sum(column: "price")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "price",
                        _value: float(v: r.price),
                    }),
            )
            |> to(bucket: toBucket_agg_2, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            |> sum(column: "prompt_tokens")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "prompt_tokens",
                        _value: int(v: r.prompt_tokens),
                    }),
            )
            |> to(bucket: toBucket_agg_2, org: org)

        data
            |> group(columns: ["_measurement", "title", "topic", "model"])
            |> sum(column: "completion_tokens")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        title: r.title,
                        topic: r.topic,
                        model: r.model,
                        _field: "completion_tokens",
                        _value: int(v: r.completion_tokens),
                    }),
            )
            |> to(bucket: toBucket_agg_2, org: org)

        //classification of prompt tokens
        data
            |> map(
                fn: (r) => ({r with user_type: if r.user_hash == "undefined" then "project" else "user"}),
            )
            |> group(columns: ["_measurement", "user_type"])
            |> map(
                fn: (r) =>
                    ({
                        _measurement: r._measurement,
                        user_type: r.user_type,
                        prompt_tokens: r.prompt_tokens,
                        prompt_token_class:
                            if r.prompt_tokens >= 50000 then
                                "class_1"
                            else if r.prompt_tokens > 10000 then
                                "class_2"
                            else if r.prompt_tokens > 5000 then
                                "class_3"
                            else if r.prompt_tokens > 1000 then
                                "class_4"
                            else if r.prompt_tokens > 100 then
                                "class_5"
                            else
                                "class_6",
                    }),
            )
            |> group(columns: ["_measurement", "user_type", "prompt_token_class"])
            |> count(column: "prompt_tokens")
            |> map(
                fn: (r) =>
                    ({
                        _time: start_time,
                        _measurement: r._measurement,
                        user_type: r.user_type,
                        _field: r.prompt_token_class,
                        _value: int(v: r.prompt_tokens),
                    }),
            )
            |> to(bucket: toBucket_agg, org: org)

        // processing data for kpi bucket
        getOrDefault = (f, d) => if exists f then f else d

        kpi_data =
            data
                |> map(fn: (r) => ({r with request_count: 1}))
                |> map(
                    fn: (r) =>
                        ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000),
                        }),
                )
                |> group(
                    columns: [
                        "_floored_time",
                        "user_hash",
                        "project_id",
                        "title",
                        // "chat_id",
                        "parent_deployment",
                    ],
                )
                |> reduce(
                    fn: (r, accumulator) =>
                        ({
                            request_count:
                                getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,
                            completion_tokens:
                                getOrDefault(f: r.completion_tokens, d: 0) + accumulator.completion_tokens,
                            prompt_tokens:
                                getOrDefault(f: r.prompt_tokens, d: 0) + accumulator.prompt_tokens,
                            price: getOrDefault(f: r.price, d: 0.0) + accumulator.price,
                        }),
                    identity: {request_count: 0, price: 0.0, completion_tokens: 0, prompt_tokens: 0},
                )

        kpi_data
            |> map(
                fn: (r) =>
                    ({
                        _time: r._floored_time,
                        _measurement: "analytics",
                        user_hash: r.user_hash,
                        project_id: r.project_id,
                        // chat_id: r.chat_id,
                        parent_deployment: r.parent_deployment,
                        title: r.title,
                        _field: "cost",
                        _value: r.price,
                    }),
            )
            |> to(bucket: toBucket_kpi, org: org)

        kpi_data
            |> map(
                fn: (r) =>
                    ({
                        _time: r._floored_time,
                        _measurement: "analytics",
                        user_hash: r.user_hash,
                        project_id: r.project_id,
                        // chat_id: r.chat_id,
                        parent_deployment: r.parent_deployment,
                        title: r.title,
                        _field: "request_count",
                        _value: r.request_count,
                    }),
            )
            |> to(bucket: toBucket_kpi, org: org)
        kpi_data
            |> map(
                fn: (r) =>
                    ({
                        _time: r._floored_time,
                        _measurement: "analytics",
                        user_hash: r.user_hash,
                        project_id: r.project_id,
                        //  chat_id: r.chat_id,
                        parent_deployment: r.parent_deployment,
                        title: r.title,
                        _field: "completion_tokens",
                        _value: r.completion_tokens,
                    }),
            )
            |> to(bucket: toBucket_kpi, org: org)
        kpi_data
            |> map(
                fn: (r) =>
                    ({
                        _time: r._floored_time,
                        _measurement: "analytics",
                        user_hash: r.user_hash,
                        project_id: r.project_id,
                        // chat_id: r.chat_id,
                        parent_deployment: r.parent_deployment,
                        title: r.title,
                        _field: "prompt_tokens",
                        _value: r.prompt_tokens,
                    }),
            )
            |> to(bucket: toBucket_kpi, org: org)

        chat_id_data =
            data
                |> map(fn: (r) => ({r with request_count: 1}))
                |> map(
                    fn: (r) =>
                        ({r with _floored_time: time(v: int(v: r._time) - int(v: r._time) % 21600000000000),
                        }),
                )
                |> group(columns: ["_floored_time", "chat_id"])
                |> reduce(
                    fn: (r, accumulator) =>
                        ({
                            request_count:
                                getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,
                        }),
                    identity: {request_count: 0},
                )

        chat_id_data
            |> map(
                fn: (r) =>
                    ({
                        _time: r._floored_time,
                        _measurement: "analytics",
                        chat_id: r.chat_id,
                        _field: "request_count",
                        _value: r.request_count,
                    }),
            )
            |> to(bucket: toBucket_chatid, org: org)
---
apiVersion: influxdata.com/v2alpha1
kind: Task
metadata:
    name: vibrant-kowalevski-1d8001
spec:
    cron: 0 0 1 * *
    name: monthly_agg
    query: "import \"influxdata/influxdb/schema\" \nimport \"experimental\" import \"date\"\n\nimport \"influxdata/influxdb/secrets\"\n\n\n\n\noption org = secrets.get(key: \"org\")\n\ngetOrDefault = (f, d) => if exists f then f else d\n\nnow_time = now()\n\nfirst_day_current_month = date.truncate(t: now_time, unit: 1mo)\n\nstart_time = experimental.addDuration(d: -1mo, to: first_day_current_month) \n\nend_time = experimental.addDuration(d: -1s, to: first_day_current_month)\n\ntoBucket_monthly = \"default_agg_month\"\n\nproject_api_data =\n    from(bucket: \"default_agg_stats\")\n        |> range(start: start_time, stop: end_time)\n        |> filter(fn: (r) => r._field == \"request_count\" or r._field == \"price\")\n        |> filter(fn: (r) => r[\"project_id\"] != \"\")\n        |> schema.fieldsAsCols()\n        |> group()\n\nmonthly_api_data =\n    project_api_data\n        |> map(\n            fn: (r) =>\n                ({r with month: date.truncate(t: r._time, unit: 1mo),\n                        // Truncate time to the month\n\n                }),\n        )\n        |> group(columns: [\"month\", \"project_id\"])\n        // Group by month and user_hash\n        |> reduce(\n            fn: (r, accumulator) =>\n                ({\n                    request_count: getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,\n                    price: getOrDefault(f: r.price, d: 0.0) + accumulator.price,\n                }),\n            identity: {request_count: 0, price: 0.0},\n        )\n\nmonthly_model_data =\n    project_api_data\n        |> map(\n            fn: (r) =>\n                ({r with month: date.truncate(t: r._time, unit: 1mo),\n                        // Truncate time to the month\n\n                }),\n        )\n        |> group(columns: [\"month\", \"model\"])\n        // Group by month and user_hash\n        |> reduce(\n            fn: (r, accumulator) =>\n                ({\n                    request_count: getOrDefault(f: r.request_count, d: 0) + accumulator.request_count,\n                    price: getOrDefault(f: r.price, d: 0.0) + accumulator.price,\n                }),\n            identity: {request_count: 0, price: 0.0},\n        )\n\ntotal_api_cost =\n    monthly_api_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> sum(column: \"price\")\n        // Sum all user costs per month\n        |> rename(columns: {price: \"Total_Cost_Per_Api\"})\n\navg_api_cost =\n    monthly_api_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> mean(column: \"price\")\n        // Compute the average cost per user\n        |> rename(columns: {price: \"Avg_Cost_Per_Api\"})\n\nunique_api =\n    monthly_api_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> count(column: \"project_id\")\n        // Compute the average cost per user\n        |> rename(columns: {project_id: \"Active_Apis\"})\n\ntotal_api_request =\n    monthly_api_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> sum(column: \"request_count\")\n        // Compute the average cost per user\n        |> rename(columns: {request_count: \"Total_RC_Per_Api\"})\n\navg_api_request =\n    monthly_api_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> mean(column: \"request_count\")\n        // Compute the average cost per user\n        |> rename(columns: {request_count: \"Avg_RC_Per_Api\"})\n\ntotal_model_cost =\n    monthly_model_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> sum(column: \"price\")\n        // Sum all user costs per month\n        |> rename(columns: {price: \"Total_Cost_Per_Model\"})\n\navg_model_cost =\n    monthly_model_data\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> mean(column: \"price\")\n        // Compute the average cost per user\n        |> rename(columns: {price: \"Avg_Cost_Per_Model\"})\n\nkpi_data =\n    from(bucket: \"default_agg_kpi\")\n        |> range(start: start_time, stop: end_time)\n        |> filter(fn: (r) => r[\"_measurement\"] == \"analytics\")\n        |> filter(fn: (r) => r[\"user_hash\"] != \"undefined\")\n        |> schema.fieldsAsCols()\n        |> group()\n\nuser_cost_per_month =\n    kpi_data\n        |> map(\n            fn: (r) =>\n                ({r with month: date.truncate(t: r._time, unit: 1mo),\n                        // Truncate time to the month\n\n                }),\n        )\n        |> group(columns: [\"month\", \"user_hash\"])\n        // Group by month and user_hash\n        |> sum(column: \"cost\")\n\ntotal_user_cost =\n    user_cost_per_month\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> sum(column: \"cost\")\n        // Sum all user costs per month\n        |> rename(columns: {cost: \"total_user_cost\"})\n\navg_per_user_per_month =\n    user_cost_per_month\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> mean(column: \"cost\")\n        // Compute the average cost per user\n        |> rename(columns: {cost: \"Avg_Cost_Per_User\"})\n\nunique_user_per_month =\n    user_cost_per_month\n        |> group(columns: [\"month\"])\n        // Group by month only\n        |> count(column: \"user_hash\")\n        // Compute the average cost per user\n        |> rename(columns: {user_hash: \"Unique_Users\"})\n\nfinal_transformed =\n    union(\n        tables: [\n            total_user_cost\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"total_user_cost\",\n                            _value: float(v: r.total_user_cost),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            avg_per_user_per_month\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Avg_Cost_Per_User\",\n                            _value: float(v: r.Avg_Cost_Per_User),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            unique_user_per_month\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Unique_Users\",\n                            _value: float(v: r.Unique_Users),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            total_api_cost\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Total_Cost_Per_Api\",\n                            _value: float(v: r.Total_Cost_Per_Api),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            avg_api_cost\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Avg_Cost_Per_Api\",\n                            _value: float(v: r.Avg_Cost_Per_Api),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            unique_api\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Active_Apis\",\n                            _value: float(v: r.Active_Apis),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            total_api_request\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Total_RC_Per_Api\",\n                            _value: float(v: r.Total_RC_Per_Api),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            avg_api_request\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Avg_RC_Per_Api\",\n                            _value: float(v: r.Avg_RC_Per_Api),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            total_model_cost\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Total_Cost_Per_Model\",\n                            _value: float(v: r.Total_Cost_Per_Model),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n            avg_model_cost\n                |> rename(columns: {month: \"_time\"})\n                |> map(\n                    fn: (r) =>\n                        ({\n                            _time: r._time,\n                            _measurement: \"analytics\",\n                            _field: \"Avg_Cost_Per_Model\",\n                            _value: float(v: r.Avg_Cost_Per_Model),\n                        }),\n                )\n                |> keep(columns: [\"_time\", \"_measurement\", \"_field\", \"_value\"]),\n        ],\n    )\n\nfinal_transformed\n    |> group()\n    |> to(bucket: toBucket_monthly, org: org)"
